From 155078666b57e519a22f2700eb7d1a595141954c Mon Sep 17 00:00:00 2001
From: chenli <chenli@loongson.cn>
Date: Mon, 21 Aug 2023 11:03:49 +0800
Subject: [PATCH 09/42] [LoongArch] Add testcases of LSX intrinsics with
 immediates

The testcases mainly cover three situations:
- the arguments which should be immediates are non immediates.
- the immediate is out of upper limit of the argument type.
- the immediate is out of lower limit of the argument type.

Depends on D155829

Reviewed By: SixWeining

Differential Revision: https://reviews.llvm.org/D157570

(cherry picked from commit 0c76f46ca676ebecbdf2c9f7e8b05421a234bbed)

Change-Id: Ib4aab73a41f64b4500a833892e181124309f30aa
---
 .../lsx/intrinsic-addi-invalid-imm.ll         |  65 +++++++++
 .../LoongArch/lsx/intrinsic-addi-non-imm.ll   |  37 +++++
 .../lsx/intrinsic-andi-invalid-imm.ll         |  17 +++
 .../LoongArch/lsx/intrinsic-andi-non-imm.ll   |  10 ++
 .../lsx/intrinsic-bitclr-invalid-imm.ll       |  65 +++++++++
 .../LoongArch/lsx/intrinsic-bitclr-non-imm.ll |  37 +++++
 .../lsx/intrinsic-bitrev-invalid-imm.ll       |  65 +++++++++
 .../LoongArch/lsx/intrinsic-bitrev-non-imm.ll |  37 +++++
 .../lsx/intrinsic-bitseli-invalid-imm.ll      |  17 +++
 .../lsx/intrinsic-bitseli-non-imm.ll          |  10 ++
 .../lsx/intrinsic-bitset-invalid-imm.ll       |  65 +++++++++
 .../LoongArch/lsx/intrinsic-bitset-non-imm.ll |  37 +++++
 .../lsx/intrinsic-bsll-invalid-imm.ll         |  17 +++
 .../LoongArch/lsx/intrinsic-bsll-non-imm.ll   |  10 ++
 .../lsx/intrinsic-bsrl-invalid-imm.ll         |  17 +++
 .../LoongArch/lsx/intrinsic-bsrl-non-imm.ll   |  10 ++
 .../lsx/intrinsic-extrins-invalid-imm.ll      |  65 +++++++++
 .../lsx/intrinsic-extrins-non-imm.ll          |  37 +++++
 .../lsx/intrinsic-frstp-invalid-imm.ll        |  33 +++++
 .../LoongArch/lsx/intrinsic-frstp-non-imm.ll  |  19 +++
 .../lsx/intrinsic-insgr2vr-invalid-imm.ll     |  65 +++++++++
 .../lsx/intrinsic-insgr2vr-non-imm.ll         |  37 +++++
 .../LoongArch/lsx/intrinsic-ld-invalid-imm.ll |  17 +++
 .../LoongArch/lsx/intrinsic-ld-non-imm.ll     |  10 ++
 .../lsx/intrinsic-ldi-invalid-imm.ll          |  81 +++++++++++
 .../LoongArch/lsx/intrinsic-ldi-non-imm.ll    |  46 +++++++
 .../lsx/intrinsic-ldrepl-invalid-imm.ll       |  65 +++++++++
 .../LoongArch/lsx/intrinsic-ldrepl-non-imm.ll |  37 +++++
 .../lsx/intrinsic-max-invalid-imm.ll          | 129 ++++++++++++++++++
 .../LoongArch/lsx/intrinsic-max-non-imm.ll    |  73 ++++++++++
 .../lsx/intrinsic-min-invalid-imm.ll          | 129 ++++++++++++++++++
 .../LoongArch/lsx/intrinsic-min-non-imm.ll    |  73 ++++++++++
 .../lsx/intrinsic-nori-invalid-imm.ll         |  17 +++
 .../LoongArch/lsx/intrinsic-nori-non-imm.ll   |  10 ++
 .../lsx/intrinsic-ori-invalid-imm.ll          |  17 +++
 .../LoongArch/lsx/intrinsic-ori-non-imm.ll    |  10 ++
 .../lsx/intrinsic-permi-invalid-imm.ll        |  17 +++
 .../LoongArch/lsx/intrinsic-permi-non-imm.ll  |  10 ++
 .../lsx/intrinsic-pickve2gr-invalid-imm.ll    | 129 ++++++++++++++++++
 .../lsx/intrinsic-pickve2gr-non-imm.ll        |  73 ++++++++++
 .../lsx/intrinsic-replvei-invalid-imm.ll      |  65 +++++++++
 .../lsx/intrinsic-replvei-non-imm.ll          |  37 +++++
 .../lsx/intrinsic-rotr-invalid-imm.ll         |  65 +++++++++
 .../LoongArch/lsx/intrinsic-rotr-non-imm.ll   |  37 +++++
 .../lsx/intrinsic-sat-invalid-imm.ll          | 129 ++++++++++++++++++
 .../LoongArch/lsx/intrinsic-sat-non-imm.ll    |  73 ++++++++++
 .../lsx/intrinsic-seq-invalid-imm.ll          |  65 +++++++++
 .../LoongArch/lsx/intrinsic-seq-non-imm.ll    |  37 +++++
 .../lsx/intrinsic-shuf4i-invalid-imm.ll       |  65 +++++++++
 .../LoongArch/lsx/intrinsic-shuf4i-non-imm.ll |  37 +++++
 .../lsx/intrinsic-sle-invalid-imm.ll          | 129 ++++++++++++++++++
 .../LoongArch/lsx/intrinsic-sle-non-imm.ll    |  73 ++++++++++
 .../lsx/intrinsic-sll-invalid-imm.ll          |  65 +++++++++
 .../LoongArch/lsx/intrinsic-sll-non-imm.ll    |  37 +++++
 .../lsx/intrinsic-sllwil-invalid-imm.ll       |  97 +++++++++++++
 .../LoongArch/lsx/intrinsic-sllwil-non-imm.ll |  55 ++++++++
 .../lsx/intrinsic-slt-invalid-imm.ll          | 129 ++++++++++++++++++
 .../LoongArch/lsx/intrinsic-slt-non-imm.ll    |  73 ++++++++++
 .../lsx/intrinsic-sra-invalid-imm.ll          |  65 +++++++++
 .../LoongArch/lsx/intrinsic-sra-non-imm.ll    |  37 +++++
 .../lsx/intrinsic-srani-invalid-imm.ll        |  65 +++++++++
 .../LoongArch/lsx/intrinsic-srani-non-imm.ll  |  37 +++++
 .../lsx/intrinsic-srar-invalid-imm.ll         |  65 +++++++++
 .../LoongArch/lsx/intrinsic-srar-non-imm.ll   |  37 +++++
 .../lsx/intrinsic-srarni-invalid-imm.ll       |  65 +++++++++
 .../LoongArch/lsx/intrinsic-srarni-non-imm.ll |  37 +++++
 .../lsx/intrinsic-srl-invalid-imm.ll          |  65 +++++++++
 .../LoongArch/lsx/intrinsic-srl-non-imm.ll    |  37 +++++
 .../lsx/intrinsic-srlni-invalid-imm.ll        |  65 +++++++++
 .../LoongArch/lsx/intrinsic-srlni-non-imm.ll  |  37 +++++
 .../lsx/intrinsic-srlr-invalid-imm.ll         |  65 +++++++++
 .../LoongArch/lsx/intrinsic-srlr-non-imm.ll   |  37 +++++
 .../lsx/intrinsic-srlrni-invalid-imm.ll       |  65 +++++++++
 .../LoongArch/lsx/intrinsic-srlrni-non-imm.ll |  37 +++++
 .../lsx/intrinsic-ssrani-invalid-imm.ll       | 129 ++++++++++++++++++
 .../LoongArch/lsx/intrinsic-ssrani-non-imm.ll |  73 ++++++++++
 .../lsx/intrinsic-ssrarni-invalid-imm.ll      | 129 ++++++++++++++++++
 .../lsx/intrinsic-ssrarni-non-imm.ll          |  73 ++++++++++
 .../lsx/intrinsic-ssrlni-invalid-imm.ll       | 129 ++++++++++++++++++
 .../LoongArch/lsx/intrinsic-ssrlni-non-imm.ll |  73 ++++++++++
 .../lsx/intrinsic-ssrlrni-invalid-imm.ll      | 129 ++++++++++++++++++
 .../lsx/intrinsic-ssrlrni-non-imm.ll          |  73 ++++++++++
 .../LoongArch/lsx/intrinsic-st-invalid-imm.ll |  17 +++
 .../LoongArch/lsx/intrinsic-st-non-imm.ll     |  10 ++
 .../lsx/intrinsic-stelm-invalid-imm.ll        | 121 ++++++++++++++++
 .../LoongArch/lsx/intrinsic-stelm-non-imm.ll  |  65 +++++++++
 .../lsx/intrinsic-subi-invalid-imm.ll         |  65 +++++++++
 .../LoongArch/lsx/intrinsic-subi-non-imm.ll   |  37 +++++
 .../lsx/intrinsic-xori-invalid-imm.ll         |  17 +++
 .../LoongArch/lsx/intrinsic-xori-non-imm.ll   |  10 ++
 90 files changed, 4949 insertions(+)
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-addi-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-addi-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-andi-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-andi-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitclr-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitclr-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitrev-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitrev-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitseli-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitseli-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitset-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitset-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsll-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsll-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsrl-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsrl-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-extrins-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-extrins-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-frstp-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-frstp-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-insgr2vr-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-insgr2vr-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ld-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ld-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldi-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldi-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldrepl-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldrepl-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-max-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-max-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-min-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-min-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-nori-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-nori-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ori-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ori-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-permi-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-permi-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-pickve2gr-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-pickve2gr-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-replvei-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-replvei-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-rotr-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-rotr-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-sat-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-sat-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-seq-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-seq-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-shuf4i-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-shuf4i-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-sle-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-sle-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-sll-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-sll-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-sllwil-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-sllwil-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-slt-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-slt-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-sra-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-sra-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srani-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srani-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srar-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srar-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srarni-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srarni-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srl-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srl-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlni-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlni-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlr-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlr-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlrni-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlrni-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrani-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrani-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrarni-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrarni-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlni-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlni-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlrni-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlrni-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-st-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-st-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-stelm-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-stelm-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-subi-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-subi-non-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-xori-invalid-imm.ll
 create mode 100644 llvm/test/CodeGen/LoongArch/lsx/intrinsic-xori-non-imm.ll

diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-addi-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-addi-invalid-imm.ll
new file mode 100644
index 000000000000..6875872b6f83
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-addi-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vaddi.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vaddi_bu_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vaddi.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vaddi.bu(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vaddi_bu_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vaddi.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vaddi.bu(<16 x i8> %va, i32 32)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vaddi.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vaddi_hu_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vaddi.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vaddi.hu(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vaddi_hu_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vaddi.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vaddi.hu(<8 x i16> %va, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vaddi.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vaddi_wu_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vaddi.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vaddi.wu(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vaddi_wu_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vaddi.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vaddi.wu(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vaddi.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vaddi_du_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vaddi.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vaddi.du(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vaddi_du_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vaddi.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vaddi.du(<2 x i64> %va, i32 32)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-addi-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-addi-non-imm.ll
new file mode 100644
index 000000000000..87d32b3ce02a
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-addi-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vaddi.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vaddi_bu(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vaddi.bu(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vaddi.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vaddi_hu(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vaddi.hu(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vaddi.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vaddi_wu(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vaddi.wu(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vaddi.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vaddi_du(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vaddi.du(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-andi-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-andi-invalid-imm.ll
new file mode 100644
index 000000000000..82a117b2aba5
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-andi-invalid-imm.ll
@@ -0,0 +1,17 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vandi.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vandi_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vandi.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vandi.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vandi_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vandi.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vandi.b(<16 x i8> %va, i32 256)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-andi-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-andi-non-imm.ll
new file mode 100644
index 000000000000..c0c35c775266
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-andi-non-imm.ll
@@ -0,0 +1,10 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vandi.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vandi_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vandi.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitclr-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitclr-invalid-imm.ll
new file mode 100644
index 000000000000..b020806cd86c
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitclr-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbitclri.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vbitclri_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitclri.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitclri.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vbitclri_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitclri.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitclri.b(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vbitclri.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vbitclri_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitclri.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vbitclri.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vbitclri_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitclri.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vbitclri.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vbitclri.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vbitclri_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitclri.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vbitclri.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vbitclri_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitclri.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vbitclri.w(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vbitclri.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vbitclri_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitclri.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vbitclri.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vbitclri_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitclri.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vbitclri.d(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitclr-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitclr-non-imm.ll
new file mode 100644
index 000000000000..df6cdb99cdbc
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitclr-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbitclri.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vbitclri_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitclri.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vbitclri.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vbitclri_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vbitclri.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vbitclri.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vbitclri_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vbitclri.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vbitclri.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vbitclri_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vbitclri.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitrev-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitrev-invalid-imm.ll
new file mode 100644
index 000000000000..24b6ec3284cb
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitrev-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbitrevi.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vbitrevi_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitrevi.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitrevi.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vbitrevi_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitrevi.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitrevi.b(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vbitrevi.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vbitrevi_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitrevi.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vbitrevi.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vbitrevi_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitrevi.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vbitrevi.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vbitrevi.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vbitrevi_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitrevi.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vbitrevi.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vbitrevi_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitrevi.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vbitrevi.w(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vbitrevi.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vbitrevi_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitrevi.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vbitrevi.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vbitrevi_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitrevi.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vbitrevi.d(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitrev-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitrev-non-imm.ll
new file mode 100644
index 000000000000..3ffb494c9907
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitrev-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbitrevi.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vbitrevi_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitrevi.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vbitrevi.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vbitrevi_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vbitrevi.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vbitrevi.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vbitrevi_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vbitrevi.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vbitrevi.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vbitrevi_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vbitrevi.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitseli-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitseli-invalid-imm.ll
new file mode 100644
index 000000000000..bc63b40e9fca
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitseli-invalid-imm.ll
@@ -0,0 +1,17 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbitseli.b(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vbitseli_b_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitseli.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitseli.b(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vbitseli_b_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitseli.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitseli.b(<16 x i8> %va, <16 x i8> %vb, i32 256)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitseli-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitseli-non-imm.ll
new file mode 100644
index 000000000000..52c1eb7d2024
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitseli-non-imm.ll
@@ -0,0 +1,10 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbitseli.b(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vbitseli_b(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitseli.b(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitset-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitset-invalid-imm.ll
new file mode 100644
index 000000000000..e57e14d8cb07
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitset-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbitseti.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vbitseti_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitseti.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitseti.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vbitseti_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitseti.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitseti.b(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vbitseti.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vbitseti_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitseti.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vbitseti.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vbitseti_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitseti.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vbitseti.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vbitseti.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vbitseti_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitseti.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vbitseti.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vbitseti_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitseti.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vbitseti.w(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vbitseti.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vbitseti_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitseti.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vbitseti.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vbitseti_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbitseti.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vbitseti.d(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitset-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitset-non-imm.ll
new file mode 100644
index 000000000000..9b2bde015ed9
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bitset-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbitseti.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vbitseti_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbitseti.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vbitseti.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vbitseti_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vbitseti.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vbitseti.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vbitseti_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vbitseti.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vbitseti.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vbitseti_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vbitseti.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsll-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsll-invalid-imm.ll
new file mode 100644
index 000000000000..eb49af49c9be
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsll-invalid-imm.ll
@@ -0,0 +1,17 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbsll.v(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vbsll_v_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbsll.v: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbsll.v(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vbsll_v_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbsll.v: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbsll.v(<16 x i8> %va, i32 32)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsll-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsll-non-imm.ll
new file mode 100644
index 000000000000..5b10c9e91a4f
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsll-non-imm.ll
@@ -0,0 +1,10 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbsll.v(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vbsll_v(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbsll.v(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsrl-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsrl-invalid-imm.ll
new file mode 100644
index 000000000000..bf56822e2ef5
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsrl-invalid-imm.ll
@@ -0,0 +1,17 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbsrl.v(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vbsrl_v_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbsrl.v: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbsrl.v(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vbsrl_v_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vbsrl.v: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbsrl.v(<16 x i8> %va, i32 32)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsrl-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsrl-non-imm.ll
new file mode 100644
index 000000000000..0bc038c869ce
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-bsrl-non-imm.ll
@@ -0,0 +1,10 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vbsrl.v(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vbsrl_v(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vbsrl.v(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-extrins-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-extrins-invalid-imm.ll
new file mode 100644
index 000000000000..7f94234ed603
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-extrins-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vextrins.b(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vextrins_b_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vextrins.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vextrins.b(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vextrins_b_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vextrins.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vextrins.b(<16 x i8> %va, <16 x i8> %vb, i32 256)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vextrins.h(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vextrins_h_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vextrins.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vextrins.h(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vextrins_h_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vextrins.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vextrins.h(<8 x i16> %va, <8 x i16> %vb, i32 256)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vextrins.w(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vextrins_w_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vextrins.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vextrins.w(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vextrins_w_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vextrins.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vextrins.w(<4 x i32> %va, <4 x i32> %vb, i32 256)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vextrins.d(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vextrins_d_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vextrins.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vextrins.d(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vextrins_d_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vextrins.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vextrins.d(<2 x i64> %va, <2 x i64> %vb, i32 256)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-extrins-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-extrins-non-imm.ll
new file mode 100644
index 000000000000..e834002bb60b
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-extrins-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vextrins.b(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vextrins_b(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vextrins.b(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vextrins.h(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vextrins_h(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vextrins.h(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vextrins.w(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vextrins_w(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vextrins.w(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vextrins.d(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vextrins_d(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vextrins.d(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-frstp-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-frstp-invalid-imm.ll
new file mode 100644
index 000000000000..0184c855c9c1
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-frstp-invalid-imm.ll
@@ -0,0 +1,33 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vfrstpi.b(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vfrstpi_b_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vfrstpi.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vfrstpi.b(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vfrstpi_b_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vfrstpi.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vfrstpi.b(<16 x i8> %va, <16 x i8> %vb, i32 32)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vfrstpi.h(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vfrstpi_h_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vfrstpi.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vfrstpi.h(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vfrstpi_h_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vfrstpi.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vfrstpi.h(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-frstp-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-frstp-non-imm.ll
new file mode 100644
index 000000000000..9583f672a305
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-frstp-non-imm.ll
@@ -0,0 +1,19 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vfrstpi.b(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vfrstpi_b(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vfrstpi.b(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vfrstpi.h(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vfrstpi_h(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vfrstpi.h(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-insgr2vr-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-insgr2vr-invalid-imm.ll
new file mode 100644
index 000000000000..3d4f84fb6e03
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-insgr2vr-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vinsgr2vr.b(<16 x i8>, i32, i32)
+
+define <16 x i8> @lsx_vinsgr2vr_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vinsgr2vr.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vinsgr2vr.b(<16 x i8> %va, i32 1, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vinsgr2vr_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vinsgr2vr.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vinsgr2vr.b(<16 x i8> %va, i32 1, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vinsgr2vr.h(<8 x i16>, i32, i32)
+
+define <8 x i16> @lsx_vinsgr2vr_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vinsgr2vr.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vinsgr2vr.h(<8 x i16> %va, i32 1, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vinsgr2vr_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vinsgr2vr.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vinsgr2vr.h(<8 x i16> %va, i32 1, i32 8)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vinsgr2vr.w(<4 x i32>, i32, i32)
+
+define <4 x i32> @lsx_vinsgr2vr_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vinsgr2vr.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vinsgr2vr.w(<4 x i32> %va, i32 1, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vinsgr2vr_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vinsgr2vr.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vinsgr2vr.w(<4 x i32> %va, i32 1, i32 4)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vinsgr2vr.d(<2 x i64>, i64, i32)
+
+define <2 x i64> @lsx_vinsgr2vr_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vinsgr2vr.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vinsgr2vr.d(<2 x i64> %va, i64 1, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vinsgr2vr_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vinsgr2vr.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vinsgr2vr.d(<2 x i64> %va, i64 1, i32 2)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-insgr2vr-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-insgr2vr-non-imm.ll
new file mode 100644
index 000000000000..2a4c2218de8c
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-insgr2vr-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vinsgr2vr.b(<16 x i8>, i32, i32)
+
+define <16 x i8> @lsx_vinsgr2vr_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vinsgr2vr.b(<16 x i8> %va, i32 1, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vinsgr2vr.h(<8 x i16>, i32, i32)
+
+define <8 x i16> @lsx_vinsgr2vr_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vinsgr2vr.h(<8 x i16> %va, i32 1, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vinsgr2vr.w(<4 x i32>, i32, i32)
+
+define <4 x i32> @lsx_vinsgr2vr_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vinsgr2vr.w(<4 x i32> %va, i32 1, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vinsgr2vr.d(<2 x i64>, i64, i32)
+
+define <2 x i64> @lsx_vinsgr2vr_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vinsgr2vr.d(<2 x i64> %va, i64 1, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ld-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ld-invalid-imm.ll
new file mode 100644
index 000000000000..3aeb30ce66b4
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ld-invalid-imm.ll
@@ -0,0 +1,17 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vld(i8*, i32)
+
+define <16 x i8> @lsx_vld_lo(i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vld: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vld(i8* %p, i32 -2049)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vld_hi(i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vld: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vld(i8* %p, i32 2048)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ld-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ld-non-imm.ll
new file mode 100644
index 000000000000..db6a0318d87a
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ld-non-imm.ll
@@ -0,0 +1,10 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vld(i8*, i32)
+
+define <16 x i8> @lsx_vld(i8* %p, i32 %a) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vld(i8* %p, i32 %a)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldi-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldi-invalid-imm.ll
new file mode 100644
index 000000000000..57f6f8e81d91
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldi-invalid-imm.ll
@@ -0,0 +1,81 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <2 x i64> @llvm.loongarch.lsx.vldi(i32)
+
+define <2 x i64> @lsx_vldi_lo() nounwind {
+; CHECK: llvm.loongarch.lsx.vldi: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vldi(i32 -4097)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vldi_hi() nounwind {
+; CHECK: llvm.loongarch.lsx.vldi: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vldi(i32 4096)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vrepli.b(i32)
+
+define <16 x i8> @lsx_vrepli_b_lo() nounwind {
+; CHECK: llvm.loongarch.lsx.vrepli.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vrepli.b(i32 -513)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vrepli_b_hi() nounwind {
+; CHECK: llvm.loongarch.lsx.vrepli.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vrepli.b(i32 512)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vrepli.h(i32)
+
+define <8 x i16> @lsx_vrepli_h_lo() nounwind {
+; CHECK: llvm.loongarch.lsx.vrepli.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vrepli.h(i32 -513)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vrepli_h_hi() nounwind {
+; CHECK: llvm.loongarch.lsx.vrepli.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vrepli.h(i32 512)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vrepli.w(i32)
+
+define <4 x i32> @lsx_vrepli_w_lo() nounwind {
+; CHECK: llvm.loongarch.lsx.vrepli.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vrepli.w(i32 -513)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vrepli_w_hi() nounwind {
+; CHECK: llvm.loongarch.lsx.vrepli.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vrepli.w(i32 512)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vrepli.d(i32)
+
+define <2 x i64> @lsx_vrepli_d_lo() nounwind {
+; CHECK: llvm.loongarch.lsx.vrepli.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vrepli.d(i32 -513)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vrepli_d_hi() nounwind {
+; CHECK: llvm.loongarch.lsx.vrepli.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vrepli.d(i32 512)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldi-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldi-non-imm.ll
new file mode 100644
index 000000000000..a8f8278f8097
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldi-non-imm.ll
@@ -0,0 +1,46 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <2 x i64> @llvm.loongarch.lsx.vldi(i32)
+
+define <2 x i64> @lsx_vldi(i32 %a) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vldi(i32 %a)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vrepli.b(i32)
+
+define <16 x i8> @lsx_vrepli_b(i32 %a) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vrepli.b(i32 %a)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vrepli.h(i32)
+
+define <8 x i16> @lsx_vrepli_h(i32 %a) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vrepli.h(i32 %a)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vrepli.w(i32)
+
+define <4 x i32> @lsx_vrepli_w(i32 %a) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vrepli.w(i32 %a)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vrepli.d(i32)
+
+define <2 x i64> @lsx_vrepli_d(i32 %a) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vrepli.d(i32 %a)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldrepl-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldrepl-invalid-imm.ll
new file mode 100644
index 000000000000..cb640e1245da
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldrepl-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vldrepl.b(i8*, i32)
+
+define <16 x i8> @lsx_vldrepl_b_lo(i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vldrepl.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vldrepl.b(i8* %p, i32 -2049)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vldrepl_b_hi(i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vldrepl.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vldrepl.b(i8* %p, i32 2048)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vldrepl.h(i8*, i32)
+
+define <8 x i16> @lsx_vldrepl_h_lo(i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vldrepl.h: argument out of range or not a multiple of 2.
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vldrepl.h(i8* %p, i32 -2050)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vldrepl_h_hi(i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vldrepl.h: argument out of range or not a multiple of 2.
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vldrepl.h(i8* %p, i32 2048)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vldrepl.w(i8*, i32)
+
+define <4 x i32> @lsx_vldrepl_w_lo(i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vldrepl.w: argument out of range or not a multiple of 4.
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vldrepl.w(i8* %p, i32 -2052)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vldrepl_w_hi(i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vldrepl.w: argument out of range or not a multiple of 4.
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vldrepl.w(i8* %p, i32 2048)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vldrepl.d(i8*, i32)
+
+define <2 x i64> @lsx_vldrepl_d_lo(i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vldrepl.d: argument out of range or not a multiple of 8.
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vldrepl.d(i8* %p, i32 -2056)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vldrepl_d_hi(i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vldrepl.d: argument out of range or not a multiple of 8.
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vldrepl.d(i8* %p, i32 2048)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldrepl-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldrepl-non-imm.ll
new file mode 100644
index 000000000000..e60b21913c69
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ldrepl-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vldrepl.b(i8*, i32)
+
+define <16 x i8> @lsx_vldrepl_b(i8* %p, i32 %a) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vldrepl.b(i8* %p, i32 %a)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vldrepl.h(i8*, i32)
+
+define <8 x i16> @lsx_vldrepl_h(i8* %p, i32 %a) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vldrepl.h(i8* %p, i32 %a)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vldrepl.w(i8*, i32)
+
+define <4 x i32> @lsx_vldrepl_w(i8* %p, i32 %a) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vldrepl.w(i8* %p, i32 %a)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vldrepl.d(i8*, i32)
+
+define <2 x i64> @lsx_vldrepl_d(i8* %p, i32 %a) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vldrepl.d(i8* %p, i32 %a)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-max-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-max-invalid-imm.ll
new file mode 100644
index 000000000000..667ba32723fc
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-max-invalid-imm.ll
@@ -0,0 +1,129 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vmaxi.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vmaxi_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmaxi.b(<16 x i8> %va, i32 -17)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vmaxi_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmaxi.b(<16 x i8> %va, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vmaxi.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vmaxi_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmaxi.h(<8 x i16> %va, i32 -17)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vmaxi_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmaxi.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vmaxi.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vmaxi_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmaxi.w(<4 x i32> %va, i32 -17)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vmaxi_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmaxi.w(<4 x i32> %va, i32 16)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vmaxi.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vmaxi_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmaxi.d(<2 x i64> %va, i32 -17)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vmaxi_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmaxi.d(<2 x i64> %va, i32 16)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vmaxi.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vmaxi_bu_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmaxi.bu(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vmaxi_bu_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmaxi.bu(<16 x i8> %va, i32 32)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vmaxi.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vmaxi_hu_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmaxi.hu(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vmaxi_hu_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmaxi.hu(<8 x i16> %va, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vmaxi.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vmaxi_wu_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmaxi.wu(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vmaxi_wu_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmaxi.wu(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vmaxi.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vmaxi_du_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmaxi.du(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vmaxi_du_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmaxi.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmaxi.du(<2 x i64> %va, i32 32)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-max-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-max-non-imm.ll
new file mode 100644
index 000000000000..34bbe3495670
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-max-non-imm.ll
@@ -0,0 +1,73 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vmaxi.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vmaxi_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmaxi.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vmaxi.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vmaxi_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmaxi.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vmaxi.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vmaxi_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmaxi.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vmaxi.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vmaxi_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmaxi.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vmaxi.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vmaxi_bu(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmaxi.bu(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vmaxi.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vmaxi_hu(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmaxi.hu(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vmaxi.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vmaxi_wu(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmaxi.wu(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vmaxi.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vmaxi_du(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmaxi.du(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-min-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-min-invalid-imm.ll
new file mode 100644
index 000000000000..b73bada4f06f
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-min-invalid-imm.ll
@@ -0,0 +1,129 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vmini.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vmini_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmini.b(<16 x i8> %va, i32 -17)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vmini_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmini.b(<16 x i8> %va, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vmini.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vmini_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmini.h(<8 x i16> %va, i32 -17)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vmini_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmini.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vmini.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vmini_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmini.w(<4 x i32> %va, i32 -17)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vmini_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmini.w(<4 x i32> %va, i32 16)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vmini.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vmini_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmini.d(<2 x i64> %va, i32 -17)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vmini_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmini.d(<2 x i64> %va, i32 16)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vmini.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vmini_bu_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmini.bu(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vmini_bu_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmini.bu(<16 x i8> %va, i32 32)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vmini.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vmini_hu_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmini.hu(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vmini_hu_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmini.hu(<8 x i16> %va, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vmini.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vmini_wu_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmini.wu(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vmini_wu_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmini.wu(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vmini.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vmini_du_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmini.du(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vmini_du_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vmini.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmini.du(<2 x i64> %va, i32 32)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-min-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-min-non-imm.ll
new file mode 100644
index 000000000000..5d9b98cec4d0
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-min-non-imm.ll
@@ -0,0 +1,73 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vmini.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vmini_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmini.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vmini.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vmini_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmini.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vmini.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vmini_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmini.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vmini.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vmini_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmini.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vmini.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vmini_bu(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vmini.bu(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vmini.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vmini_hu(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vmini.hu(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vmini.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vmini_wu(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vmini.wu(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vmini.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vmini_du(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vmini.du(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-nori-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-nori-invalid-imm.ll
new file mode 100644
index 000000000000..8c59d8fb9fa5
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-nori-invalid-imm.ll
@@ -0,0 +1,17 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vnori.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vnori_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vnori.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vnori.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vnori_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vnori.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vnori.b(<16 x i8> %va, i32 256)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-nori-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-nori-non-imm.ll
new file mode 100644
index 000000000000..322a39c106a6
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-nori-non-imm.ll
@@ -0,0 +1,10 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vnori.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vnori_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vnori.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ori-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ori-invalid-imm.ll
new file mode 100644
index 000000000000..4a7fc7e109d9
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ori-invalid-imm.ll
@@ -0,0 +1,17 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vori.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vori_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vori.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vori.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vori_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vori.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vori.b(<16 x i8> %va, i32 256)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ori-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ori-non-imm.ll
new file mode 100644
index 000000000000..5644b8581dce
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ori-non-imm.ll
@@ -0,0 +1,10 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vori.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vori_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vori.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-permi-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-permi-invalid-imm.ll
new file mode 100644
index 000000000000..e439bbae6130
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-permi-invalid-imm.ll
@@ -0,0 +1,17 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <4 x i32> @llvm.loongarch.lsx.vpermi.w(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vpermi_w_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vpermi.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vpermi.w(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vpermi_w_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vpermi.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vpermi.w(<4 x i32> %va, <4 x i32> %vb, i32 256)
+  ret <4 x i32> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-permi-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-permi-non-imm.ll
new file mode 100644
index 000000000000..bdfc08ed680a
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-permi-non-imm.ll
@@ -0,0 +1,10 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <4 x i32> @llvm.loongarch.lsx.vpermi.w(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vpermi_w(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vpermi.w(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-pickve2gr-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-pickve2gr-invalid-imm.ll
new file mode 100644
index 000000000000..3430c54d2194
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-pickve2gr-invalid-imm.ll
@@ -0,0 +1,129 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.b(<16 x i8>, i32)
+
+define i32 @lsx_vpickve2gr_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.b: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.b(<16 x i8> %va, i32 -1)
+  ret i32 %res
+}
+
+define i32 @lsx_vpickve2gr_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.b: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.b(<16 x i8> %va, i32 16)
+  ret i32 %res
+}
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.h(<8 x i16>, i32)
+
+define i32 @lsx_vpickve2gr_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.h: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.h(<8 x i16> %va, i32 -1)
+  ret i32 %res
+}
+
+define i32 @lsx_vpickve2gr_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.h: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.h(<8 x i16> %va, i32 8)
+  ret i32 %res
+}
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.w(<4 x i32>, i32)
+
+define i32 @lsx_vpickve2gr_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.w: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.w(<4 x i32> %va, i32 -1)
+  ret i32 %res
+}
+
+define i32 @lsx_vpickve2gr_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.w: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.w(<4 x i32> %va, i32 4)
+  ret i32 %res
+}
+
+declare i64 @llvm.loongarch.lsx.vpickve2gr.d(<2 x i64>, i32)
+
+define i64 @lsx_vpickve2gr_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.d: argument out of range
+entry:
+  %res = call i64 @llvm.loongarch.lsx.vpickve2gr.d(<2 x i64> %va, i32 -1)
+  ret i64 %res
+}
+
+define i64 @lsx_vpickve2gr_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.d: argument out of range
+entry:
+  %res = call i64 @llvm.loongarch.lsx.vpickve2gr.d(<2 x i64> %va, i32 2)
+  ret i64 %res
+}
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.bu(<16 x i8>, i32)
+
+define i32 @lsx_vpickve2gr_bu_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.bu: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.bu(<16 x i8> %va, i32 -1)
+  ret i32 %res
+}
+
+define i32 @lsx_vpickve2gr_bu_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.bu: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.bu(<16 x i8> %va, i32 16)
+  ret i32 %res
+}
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.hu(<8 x i16>, i32)
+
+define i32 @lsx_vpickve2gr_hu_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.hu: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.hu(<8 x i16> %va, i32 -1)
+  ret i32 %res
+}
+
+define i32 @lsx_vpickve2gr_hu_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.hu: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.hu(<8 x i16> %va, i32 8)
+  ret i32 %res
+}
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.wu(<4 x i32>, i32)
+
+define i32 @lsx_vpickve2gr_wu_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.wu: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.wu(<4 x i32> %va, i32 -1)
+  ret i32 %res
+}
+
+define i32 @lsx_vpickve2gr_wu_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.wu: argument out of range
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.wu(<4 x i32> %va, i32 4)
+  ret i32 %res
+}
+
+declare i64 @llvm.loongarch.lsx.vpickve2gr.du(<2 x i64>, i32)
+
+define i64 @lsx_vpickve2gr_du_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.du: argument out of range
+entry:
+  %res = call i64 @llvm.loongarch.lsx.vpickve2gr.du(<2 x i64> %va, i32 -1)
+  ret i64 %res
+}
+
+define i64 @lsx_vpickve2gr_du_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vpickve2gr.du: argument out of range
+entry:
+  %res = call i64 @llvm.loongarch.lsx.vpickve2gr.du(<2 x i64> %va, i32 2)
+  ret i64 %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-pickve2gr-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-pickve2gr-non-imm.ll
new file mode 100644
index 000000000000..6dd3c1f27a81
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-pickve2gr-non-imm.ll
@@ -0,0 +1,73 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.b(<16 x i8>, i32)
+
+define i32 @lsx_vpickve2gr_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.b(<16 x i8> %va, i32 %b)
+  ret i32 %res
+}
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.h(<8 x i16>, i32)
+
+define i32 @lsx_vpickve2gr_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.h(<8 x i16> %va, i32 %b)
+  ret i32 %res
+}
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.w(<4 x i32>, i32)
+
+define i32 @lsx_vpickve2gr_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.w(<4 x i32> %va, i32 %b)
+  ret i32 %res
+}
+
+declare i64 @llvm.loongarch.lsx.vpickve2gr.d(<2 x i64>, i32)
+
+define i64 @lsx_vpickve2gr_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call i64 @llvm.loongarch.lsx.vpickve2gr.d(<2 x i64> %va, i32 %b)
+  ret i64 %res
+}
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.bu(<16 x i8>, i32)
+
+define i32 @lsx_vpickve2gr_bu(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.bu(<16 x i8> %va, i32 %b)
+  ret i32 %res
+}
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.hu(<8 x i16>, i32)
+
+define i32 @lsx_vpickve2gr_hu(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.hu(<8 x i16> %va, i32 %b)
+  ret i32 %res
+}
+
+declare i32 @llvm.loongarch.lsx.vpickve2gr.wu(<4 x i32>, i32)
+
+define i32 @lsx_vpickve2gr_wu(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call i32 @llvm.loongarch.lsx.vpickve2gr.wu(<4 x i32> %va, i32 %b)
+  ret i32 %res
+}
+
+declare i64 @llvm.loongarch.lsx.vpickve2gr.du(<2 x i64>, i32)
+
+define i64 @lsx_vpickve2gr_du(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call i64 @llvm.loongarch.lsx.vpickve2gr.du(<2 x i64> %va, i32 %b)
+  ret i64 %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-replvei-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-replvei-invalid-imm.ll
new file mode 100644
index 000000000000..d625441122a6
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-replvei-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vreplvei.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vreplvei_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vreplvei.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vreplvei.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vreplvei_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vreplvei.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vreplvei.b(<16 x i8> %va, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vreplvei.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vreplvei_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vreplvei.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vreplvei.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vreplvei_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vreplvei.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vreplvei.h(<8 x i16> %va, i32 8)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vreplvei.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vreplvei_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vreplvei.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vreplvei.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vreplvei_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vreplvei.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vreplvei.w(<4 x i32> %va, i32 4)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vreplvei.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vreplvei_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vreplvei.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vreplvei.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vreplvei_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vreplvei.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vreplvei.d(<2 x i64> %va, i32 2)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-replvei-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-replvei-non-imm.ll
new file mode 100644
index 000000000000..3d271bb2b307
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-replvei-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vreplvei.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vreplvei_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vreplvei.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vreplvei.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vreplvei_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vreplvei.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vreplvei.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vreplvei_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vreplvei.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vreplvei.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vreplvei_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vreplvei.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-rotr-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-rotr-invalid-imm.ll
new file mode 100644
index 000000000000..3c53b36672ad
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-rotr-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vrotri.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vrotri_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vrotri.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vrotri.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vrotri_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vrotri.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vrotri.b(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vrotri.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vrotri_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vrotri.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vrotri.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vrotri_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vrotri.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vrotri.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vrotri.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vrotri_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vrotri.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vrotri.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vrotri_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vrotri.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vrotri.w(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vrotri.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vrotri_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vrotri.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vrotri.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vrotri_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vrotri.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vrotri.d(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-rotr-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-rotr-non-imm.ll
new file mode 100644
index 000000000000..fd8ba3a1c633
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-rotr-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vrotri.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vrotri_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vrotri.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vrotri.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vrotri_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vrotri.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vrotri.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vrotri_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vrotri.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vrotri.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vrotri_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vrotri.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sat-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sat-invalid-imm.ll
new file mode 100644
index 000000000000..45fa4e43be19
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sat-invalid-imm.ll
@@ -0,0 +1,129 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsat.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsat_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsat.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsat_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsat.b(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsat.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsat_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsat.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsat_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsat.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsat.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsat_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsat.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsat_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsat.w(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsat.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsat_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsat.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsat_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsat.d(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vsat.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsat_bu_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsat.bu(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsat_bu_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsat.bu(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsat.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsat_hu_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsat.hu(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsat_hu_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsat.hu(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsat.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsat_wu_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsat.wu(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsat_wu_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsat.wu(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsat.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsat_du_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsat.du(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsat_du_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsat.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsat.du(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sat-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sat-non-imm.ll
new file mode 100644
index 000000000000..afdbe0c1ce0b
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sat-non-imm.ll
@@ -0,0 +1,73 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsat.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsat_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsat.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsat.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsat_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsat.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsat.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsat_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsat.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsat.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsat_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsat.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vsat.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsat_bu(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsat.bu(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsat.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsat_hu(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsat.hu(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsat.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsat_wu(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsat.wu(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsat.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsat_du(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsat.du(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-seq-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-seq-invalid-imm.ll
new file mode 100644
index 000000000000..220398ff28cd
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-seq-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vseqi.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vseqi_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vseqi.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vseqi.b(<16 x i8> %va, i32 -17)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vseqi_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vseqi.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vseqi.b(<16 x i8> %va, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vseqi.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vseqi_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vseqi.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vseqi.h(<8 x i16> %va, i32 -17)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vseqi_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vseqi.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vseqi.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vseqi.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vseqi_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vseqi.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vseqi.w(<4 x i32> %va, i32 -17)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vseqi_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vseqi.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vseqi.w(<4 x i32> %va, i32 16)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vseqi.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vseqi_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vseqi.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vseqi.d(<2 x i64> %va, i32 -17)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vseqi_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vseqi.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vseqi.d(<2 x i64> %va, i32 16)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-seq-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-seq-non-imm.ll
new file mode 100644
index 000000000000..5fa1dd30475c
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-seq-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vseqi.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vseqi_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vseqi.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vseqi.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vseqi_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vseqi.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vseqi.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vseqi_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vseqi.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vseqi.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vseqi_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vseqi.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-shuf4i-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-shuf4i-invalid-imm.ll
new file mode 100644
index 000000000000..4d6fadf08c26
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-shuf4i-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vshuf4i.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vshuf4i_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vshuf4i.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vshuf4i.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vshuf4i_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vshuf4i.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vshuf4i.b(<16 x i8> %va, i32 256)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vshuf4i.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vshuf4i_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vshuf4i.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vshuf4i.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vshuf4i_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vshuf4i.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vshuf4i.h(<8 x i16> %va, i32 256)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vshuf4i.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vshuf4i_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vshuf4i.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vshuf4i.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vshuf4i_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vshuf4i.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vshuf4i.w(<4 x i32> %va, i32 256)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vshuf4i.d(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vshuf4i_d_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vshuf4i.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vshuf4i.d(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vshuf4i_d_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vshuf4i.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vshuf4i.d(<2 x i64> %va, <2 x i64> %vb, i32 256)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-shuf4i-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-shuf4i-non-imm.ll
new file mode 100644
index 000000000000..a7d138bcc00b
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-shuf4i-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vshuf4i.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vshuf4i_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vshuf4i.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vshuf4i.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vshuf4i_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vshuf4i.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vshuf4i.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vshuf4i_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vshuf4i.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vshuf4i.d(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vshuf4i_d(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vshuf4i.d(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sle-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sle-invalid-imm.ll
new file mode 100644
index 000000000000..4c945e296711
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sle-invalid-imm.ll
@@ -0,0 +1,129 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vslei.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vslei_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslei.b(<16 x i8> %va, i32 -17)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vslei_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslei.b(<16 x i8> %va, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vslei.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vslei_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslei.h(<8 x i16> %va, i32 -17)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vslei_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslei.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vslei.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vslei_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslei.w(<4 x i32> %va, i32 -17)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vslei_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslei.w(<4 x i32> %va, i32 16)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vslei.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vslei_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslei.d(<2 x i64> %va, i32 -17)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vslei_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslei.d(<2 x i64> %va, i32 16)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vslei.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vslei_bu_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslei.bu(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vslei_bu_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslei.bu(<16 x i8> %va, i32 32)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vslei.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vslei_hu_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslei.hu(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vslei_hu_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslei.hu(<8 x i16> %va, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vslei.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vslei_wu_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslei.wu(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vslei_wu_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslei.wu(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vslei.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vslei_du_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslei.du(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vslei_du_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslei.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslei.du(<2 x i64> %va, i32 32)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sle-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sle-non-imm.ll
new file mode 100644
index 000000000000..0fc137bf0549
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sle-non-imm.ll
@@ -0,0 +1,73 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vslei.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vslei_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslei.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vslei.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vslei_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslei.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vslei.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vslei_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslei.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vslei.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vslei_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslei.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vslei.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vslei_bu(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslei.bu(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vslei.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vslei_hu(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslei.hu(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vslei.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vslei_wu(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslei.wu(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vslei.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vslei_du(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslei.du(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sll-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sll-invalid-imm.ll
new file mode 100644
index 000000000000..75406f94887c
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sll-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vslli.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vslli_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslli.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslli.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vslli_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslli.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslli.b(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vslli.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vslli_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslli.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslli.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vslli_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslli.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslli.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vslli.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vslli_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslli.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslli.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vslli_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslli.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslli.w(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vslli.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vslli_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslli.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslli.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vslli_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslli.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslli.d(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sll-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sll-non-imm.ll
new file mode 100644
index 000000000000..7474b5e29734
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sll-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vslli.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vslli_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslli.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vslli.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vslli_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslli.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vslli.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vslli_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslli.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vslli.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vslli_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslli.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sllwil-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sllwil-invalid-imm.ll
new file mode 100644
index 000000000000..bda3523a0b5c
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sllwil-invalid-imm.ll
@@ -0,0 +1,97 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <8 x i16> @llvm.loongarch.lsx.vsllwil.h.b(<16 x i8>, i32)
+
+define <8 x i16> @lsx_vsllwil_h_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.h.b: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsllwil.h.b(<16 x i8> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsllwil_h_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.h.b: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsllwil.h.b(<16 x i8> %va, i32 8)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsllwil.w.h(<8 x i16>, i32)
+
+define <4 x i32> @lsx_vsllwil_w_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.w.h: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsllwil.w.h(<8 x i16> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsllwil_w_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.w.h: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsllwil.w.h(<8 x i16> %va, i32 16)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsllwil.d.w(<4 x i32>, i32)
+
+define <2 x i64> @lsx_vsllwil_d_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.d.w: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsllwil.d.w(<4 x i32> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsllwil_d_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.d.w: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsllwil.d.w(<4 x i32> %va, i32 32)
+  ret <2 x i64> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsllwil.hu.bu(<16 x i8>, i32)
+
+define <8 x i16> @lsx_vsllwil_hu_bu_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.hu.bu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsllwil.hu.bu(<16 x i8> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsllwil_hu_bu_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.hu.bu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsllwil.hu.bu(<16 x i8> %va, i32 8)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsllwil.wu.hu(<8 x i16>, i32)
+
+define <4 x i32> @lsx_vsllwil_wu_hu_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.wu.hu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsllwil.wu.hu(<8 x i16> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsllwil_wu_hu_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.wu.hu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsllwil.wu.hu(<8 x i16> %va, i32 16)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsllwil.du.wu(<4 x i32>, i32)
+
+define <2 x i64> @lsx_vsllwil_du_wu_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.du.wu: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsllwil.du.wu(<4 x i32> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsllwil_du_wu_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsllwil.du.wu: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsllwil.du.wu(<4 x i32> %va, i32 32)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sllwil-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sllwil-non-imm.ll
new file mode 100644
index 000000000000..a03656d5ca07
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sllwil-non-imm.ll
@@ -0,0 +1,55 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <8 x i16> @llvm.loongarch.lsx.vsllwil.h.b(<16 x i8>, i32)
+
+define <8 x i16> @lsx_vsllwil_h_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsllwil.h.b(<16 x i8> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsllwil.w.h(<8 x i16>, i32)
+
+define <4 x i32> @lsx_vsllwil_w_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsllwil.w.h(<8 x i16> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsllwil.d.w(<4 x i32>, i32)
+
+define <2 x i64> @lsx_vsllwil_d_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsllwil.d.w(<4 x i32> %va, i32 %b)
+  ret <2 x i64> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsllwil.hu.bu(<16 x i8>, i32)
+
+define <8 x i16> @lsx_vsllwil_hu_bu(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsllwil.hu.bu(<16 x i8> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsllwil.wu.hu(<8 x i16>, i32)
+
+define <4 x i32> @lsx_vsllwil_wu_hu(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsllwil.wu.hu(<8 x i16> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsllwil.du.wu(<4 x i32>, i32)
+
+define <2 x i64> @lsx_vsllwil_du_wu(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsllwil.du.wu(<4 x i32> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-slt-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-slt-invalid-imm.ll
new file mode 100644
index 000000000000..f6d014b19d6c
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-slt-invalid-imm.ll
@@ -0,0 +1,129 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vslti.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vslti_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslti.b(<16 x i8> %va, i32 -17)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vslti_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslti.b(<16 x i8> %va, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vslti.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vslti_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslti.h(<8 x i16> %va, i32 -17)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vslti_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslti.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vslti.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vslti_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslti.w(<4 x i32> %va, i32 -17)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vslti_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslti.w(<4 x i32> %va, i32 16)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vslti.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vslti_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslti.d(<2 x i64> %va, i32 -17)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vslti_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslti.d(<2 x i64> %va, i32 16)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vslti.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vslti_bu_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslti.bu(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vslti_bu_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslti.bu(<16 x i8> %va, i32 32)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vslti.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vslti_hu_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslti.hu(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vslti_hu_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslti.hu(<8 x i16> %va, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vslti.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vslti_wu_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslti.wu(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vslti_wu_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslti.wu(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vslti.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vslti_du_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslti.du(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vslti_du_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vslti.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslti.du(<2 x i64> %va, i32 32)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-slt-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-slt-non-imm.ll
new file mode 100644
index 000000000000..9a8b757dab4e
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-slt-non-imm.ll
@@ -0,0 +1,73 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vslti.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vslti_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslti.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vslti.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vslti_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslti.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vslti.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vslti_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslti.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vslti.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vslti_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslti.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vslti.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vslti_bu(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vslti.bu(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vslti.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vslti_hu(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vslti.hu(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vslti.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vslti_wu(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vslti.wu(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vslti.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vslti_du(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vslti.du(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sra-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sra-invalid-imm.ll
new file mode 100644
index 000000000000..2a033a21b565
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sra-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrai.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrai_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrai.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrai.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsrai_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrai.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrai.b(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrai.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrai_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrai.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrai.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsrai_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrai.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrai.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrai.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrai_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrai.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrai.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsrai_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrai.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrai.w(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrai.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrai_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrai.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrai.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsrai_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrai.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrai.d(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sra-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sra-non-imm.ll
new file mode 100644
index 000000000000..c3b328145864
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-sra-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrai.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrai_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrai.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrai.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrai_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrai.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrai.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrai_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrai.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrai.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrai_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrai.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srani-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srani-invalid-imm.ll
new file mode 100644
index 000000000000..d68064e9b902
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srani-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrani.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrani_b_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrani.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrani.b.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsrani_b_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrani.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrani.b.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrani.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrani_h_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrani.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrani.h.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsrani_h_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrani.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrani.h.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrani.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrani_w_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrani.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrani.w.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsrani_w_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrani.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrani.w.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrani.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrani_d_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrani.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrani.d.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsrani_d_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrani.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrani.d.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srani-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srani-non-imm.ll
new file mode 100644
index 000000000000..38cfde214dc1
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srani-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrani.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrani_b_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrani.b.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrani.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrani_h_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrani.h.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrani.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrani_w_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrani.w.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrani.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrani_d_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrani.d.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srar-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srar-invalid-imm.ll
new file mode 100644
index 000000000000..b6c2d70cebbc
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srar-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrari.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrari_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrari.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrari.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsrari_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrari.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrari.b(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrari.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrari_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrari.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrari.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsrari_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrari.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrari.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrari.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrari_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrari.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrari.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsrari_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrari.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrari.w(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrari.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrari_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrari.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrari.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsrari_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrari.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrari.d(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srar-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srar-non-imm.ll
new file mode 100644
index 000000000000..2ad8adcd823b
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srar-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrari.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrari_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrari.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrari.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrari_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrari.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrari.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrari_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrari.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrari.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrari_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrari.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srarni-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srarni-invalid-imm.ll
new file mode 100644
index 000000000000..d24cf92a0392
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srarni-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrarni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrarni_b_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrarni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrarni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsrarni_b_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrarni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrarni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrarni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrarni_h_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrarni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrarni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsrarni_h_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrarni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrarni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrarni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrarni_w_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrarni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrarni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsrarni_w_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrarni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrarni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrarni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrarni_d_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrarni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrarni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsrarni_d_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrarni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrarni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srarni-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srarni-non-imm.ll
new file mode 100644
index 000000000000..19de7445cba1
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srarni-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrarni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrarni_b_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrarni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrarni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrarni_h_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrarni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrarni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrarni_w_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrarni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrarni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrarni_d_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrarni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srl-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srl-invalid-imm.ll
new file mode 100644
index 000000000000..3beff790afab
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srl-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrli.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrli_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrli.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrli.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsrli_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrli.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrli.b(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrli.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrli_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrli.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrli.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsrli_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrli.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrli.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrli.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrli_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrli.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrli.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsrli_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrli.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrli.w(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrli.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrli_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrli.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrli.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsrli_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrli.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrli.d(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srl-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srl-non-imm.ll
new file mode 100644
index 000000000000..98652aca0d62
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srl-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrli.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrli_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrli.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrli.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrli_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrli.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrli.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrli_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrli.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrli.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrli_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrli.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlni-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlni-invalid-imm.ll
new file mode 100644
index 000000000000..054c4f393548
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlni-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrlni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrlni_b_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrlni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsrlni_b_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrlni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrlni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrlni_h_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrlni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsrlni_h_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrlni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrlni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrlni_w_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrlni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsrlni_w_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrlni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrlni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrlni_d_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrlni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsrlni_d_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrlni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlni-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlni-non-imm.ll
new file mode 100644
index 000000000000..76341df197fd
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlni-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrlni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrlni_b_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrlni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrlni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrlni_h_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrlni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrlni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrlni_w_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrlni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrlni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrlni_d_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrlni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlr-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlr-invalid-imm.ll
new file mode 100644
index 000000000000..bcbd38e26e5f
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlr-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrlri.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrlri_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlri.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrlri.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsrlri_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlri.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrlri.b(<16 x i8> %va, i32 8)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrlri.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrlri_h_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlri.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrlri.h(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsrlri_h_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlri.h: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrlri.h(<8 x i16> %va, i32 16)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrlri.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrlri_w_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlri.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrlri.w(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsrlri_w_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlri.w: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrlri.w(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrlri.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrlri_d_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlri.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrlri.d(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsrlri_d_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlri.d: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrlri.d(<2 x i64> %va, i32 64)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlr-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlr-non-imm.ll
new file mode 100644
index 000000000000..4862b1546ccf
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlr-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrlri.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrlri_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrlri.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrlri.h(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrlri_h(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrlri.h(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrlri.w(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrlri_w(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrlri.w(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrlri.d(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrlri_d(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrlri.d(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlrni-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlrni-invalid-imm.ll
new file mode 100644
index 000000000000..8988ae88f9eb
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlrni-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrlrni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrlrni_b_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlrni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrlrni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsrlrni_b_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlrni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrlrni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrlrni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrlrni_h_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlrni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrlrni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsrlrni_h_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlrni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrlrni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrlrni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrlrni_w_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlrni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrlrni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsrlrni_w_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlrni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrlrni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrlrni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrlrni_d_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlrni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrlrni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsrlrni_d_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vsrlrni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrlrni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlrni-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlrni-non-imm.ll
new file mode 100644
index 000000000000..e5530db56fed
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-srlrni-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsrlrni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vsrlrni_b_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsrlrni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsrlrni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vsrlrni_h_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsrlrni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsrlrni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vsrlrni_w_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsrlrni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsrlrni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vsrlrni_d_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsrlrni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrani-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrani-invalid-imm.ll
new file mode 100644
index 000000000000..f7817921ebeb
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrani-invalid-imm.ll
@@ -0,0 +1,129 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrani.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrani_b_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrani.b.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vssrani_b_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrani.b.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrani.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrani_h_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrani.h.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vssrani_h_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrani.h.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrani.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrani_w_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrani.w.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vssrani_w_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrani.w.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrani.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrani_d_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrani.d.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vssrani_d_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrani.d.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrani.bu.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrani_bu_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.bu.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrani.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vssrani_bu_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.bu.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrani.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrani.hu.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrani_hu_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.hu.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrani.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vssrani_hu_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.hu.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrani.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrani.wu.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrani_wu_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.wu.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrani.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vssrani_wu_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.wu.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrani.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrani.du.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrani_du_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.du.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrani.du.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vssrani_du_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrani.du.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrani.du.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrani-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrani-non-imm.ll
new file mode 100644
index 000000000000..a80ede9c5243
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrani-non-imm.ll
@@ -0,0 +1,73 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrani.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrani_b_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrani.b.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrani.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrani_h_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrani.h.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrani.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrani_w_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrani.w.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrani.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrani_d_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrani.d.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrani.bu.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrani_bu_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrani.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrani.hu.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrani_hu_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrani.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrani.wu.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrani_wu_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrani.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrani.du.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrani_du_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrani.du.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrarni-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrarni-invalid-imm.ll
new file mode 100644
index 000000000000..4edda8c0a24a
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrarni-invalid-imm.ll
@@ -0,0 +1,129 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrarni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrarni_b_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrarni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vssrarni_b_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrarni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrarni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrarni_h_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrarni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vssrarni_h_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrarni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrarni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrarni_w_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrarni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vssrarni_w_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrarni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrarni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrarni_d_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrarni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vssrarni_d_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrarni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrarni.bu.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrarni_bu_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.bu.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrarni.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vssrarni_bu_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.bu.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrarni.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrarni.hu.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrarni_hu_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.hu.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrarni.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vssrarni_hu_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.hu.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrarni.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrarni.wu.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrarni_wu_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.wu.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrarni.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vssrarni_wu_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.wu.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrarni.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrarni.du.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrarni_du_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.du.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrarni.du.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vssrarni_du_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrarni.du.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrarni.du.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrarni-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrarni-non-imm.ll
new file mode 100644
index 000000000000..a77e6e764c9d
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrarni-non-imm.ll
@@ -0,0 +1,73 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrarni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrarni_b_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrarni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrarni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrarni_h_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrarni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrarni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrarni_w_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrarni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrarni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrarni_d_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrarni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrarni.bu.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrarni_bu_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrarni.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrarni.hu.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrarni_hu_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrarni.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrarni.wu.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrarni_wu_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrarni.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrarni.du.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrarni_du_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrarni.du.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlni-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlni-invalid-imm.ll
new file mode 100644
index 000000000000..6218af1fa773
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlni-invalid-imm.ll
@@ -0,0 +1,129 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrlni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrlni_b_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vssrlni_b_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrlni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrlni_h_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vssrlni_h_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrlni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrlni_w_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vssrlni_w_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrlni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrlni_d_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vssrlni_d_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrlni.bu.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrlni_bu_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.bu.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlni.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vssrlni_bu_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.bu.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlni.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrlni.hu.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrlni_hu_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.hu.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlni.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vssrlni_hu_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.hu.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlni.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrlni.wu.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrlni_wu_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.wu.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlni.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vssrlni_wu_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.wu.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlni.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrlni.du.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrlni_du_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.du.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlni.du.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vssrlni_du_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlni.du.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlni.du.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlni-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlni-non-imm.ll
new file mode 100644
index 000000000000..688be826f467
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlni-non-imm.ll
@@ -0,0 +1,73 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrlni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrlni_b_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrlni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrlni_h_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrlni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrlni_w_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrlni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrlni_d_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrlni.bu.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrlni_bu_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlni.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrlni.hu.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrlni_hu_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlni.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrlni.wu.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrlni_wu_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlni.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrlni.du.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrlni_du_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlni.du.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlrni-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlrni-invalid-imm.ll
new file mode 100644
index 000000000000..98a0c5b3cd28
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlrni-invalid-imm.ll
@@ -0,0 +1,129 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrlrni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrlrni_b_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlrni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vssrlrni_b_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.b.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlrni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrlrni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrlrni_h_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlrni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vssrlrni_h_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.h.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlrni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrlrni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrlrni_w_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlrni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vssrlrni_w_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.w.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlrni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrlrni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrlrni_d_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlrni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vssrlrni_d_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.d.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlrni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrlrni.bu.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrlrni_bu_h_lo(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.bu.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlrni.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vssrlrni_bu_h_hi(<16 x i8> %va, <16 x i8> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.bu.h: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlrni.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 16)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrlrni.hu.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrlrni_hu_w_lo(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.hu.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlrni.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vssrlrni_hu_w_hi(<8 x i16> %va, <8 x i16> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.hu.w: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlrni.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrlrni.wu.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrlrni_wu_d_lo(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.wu.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlrni.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vssrlrni_wu_d_hi(<4 x i32> %va, <4 x i32> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.wu.d: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlrni.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 64)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrlrni.du.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrlrni_du_q_lo(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.du.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlrni.du.q(<2 x i64> %va, <2 x i64> %vb, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vssrlrni_du_q_hi(<2 x i64> %va, <2 x i64> %vb) nounwind {
+; CHECK: llvm.loongarch.lsx.vssrlrni.du.q: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlrni.du.q(<2 x i64> %va, <2 x i64> %vb, i32 128)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlrni-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlrni-non-imm.ll
new file mode 100644
index 000000000000..c389b4fd6023
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-ssrlrni-non-imm.ll
@@ -0,0 +1,73 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrlrni.b.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrlrni_b_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlrni.b.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrlrni.h.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrlrni_h_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlrni.h.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrlrni.w.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrlrni_w_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlrni.w.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrlrni.d.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrlrni_d_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlrni.d.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
+
+declare <16 x i8> @llvm.loongarch.lsx.vssrlrni.bu.h(<16 x i8>, <16 x i8>, i32)
+
+define <16 x i8> @lsx_vssrlrni_bu_h(<16 x i8> %va, <16 x i8> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vssrlrni.bu.h(<16 x i8> %va, <16 x i8> %vb, i32 %c)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vssrlrni.hu.w(<8 x i16>, <8 x i16>, i32)
+
+define <8 x i16> @lsx_vssrlrni_hu_w(<8 x i16> %va, <8 x i16> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vssrlrni.hu.w(<8 x i16> %va, <8 x i16> %vb, i32 %c)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vssrlrni.wu.d(<4 x i32>, <4 x i32>, i32)
+
+define <4 x i32> @lsx_vssrlrni_wu_d(<4 x i32> %va, <4 x i32> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vssrlrni.wu.d(<4 x i32> %va, <4 x i32> %vb, i32 %c)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vssrlrni.du.q(<2 x i64>, <2 x i64>, i32)
+
+define <2 x i64> @lsx_vssrlrni_du_q(<2 x i64> %va, <2 x i64> %vb, i32 %c) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vssrlrni.du.q(<2 x i64> %va, <2 x i64> %vb, i32 %c)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-st-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-st-invalid-imm.ll
new file mode 100644
index 000000000000..64518380964b
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-st-invalid-imm.ll
@@ -0,0 +1,17 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare void @llvm.loongarch.lsx.vst(<16 x i8>, i8*, i32)
+
+define void @lsx_vst_lo(<16 x i8> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vst: argument out of range
+entry:
+  call void @llvm.loongarch.lsx.vst(<16 x i8> %va, i8* %p, i32 -2049)
+  ret void
+}
+
+define void @lsx_vst_hi(<16 x i8> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vst: argument out of range
+entry:
+  call void @llvm.loongarch.lsx.vst(<16 x i8> %va, i8* %p, i32 2048)
+  ret void
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-st-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-st-non-imm.ll
new file mode 100644
index 000000000000..119ed9b78658
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-st-non-imm.ll
@@ -0,0 +1,10 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare void @llvm.loongarch.lsx.vst(<16 x i8>, i8*, i32)
+
+define void @lsx_vst(<16 x i8> %va, i8* %p, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  call void @llvm.loongarch.lsx.vst(<16 x i8> %va, i8* %p, i32 %b)
+  ret void
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-stelm-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-stelm-invalid-imm.ll
new file mode 100644
index 000000000000..277abcbd34cc
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-stelm-invalid-imm.ll
@@ -0,0 +1,121 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare void @llvm.loongarch.lsx.vstelm.b(<16 x i8>, i8*, i32, i32)
+
+define void @lsx_vstelm_b_lo(<16 x i8> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.b: argument out of range
+entry:
+  call void @llvm.loongarch.lsx.vstelm.b(<16 x i8> %va, i8* %p, i32 -129, i32 15)
+  ret void
+}
+
+define void @lsx_vstelm_b_hi(<16 x i8> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.b: argument out of range
+entry:
+  call void @llvm.loongarch.lsx.vstelm.b(<16 x i8> %va, i8* %p, i32 128, i32 15)
+  ret void
+}
+
+define void @lsx_vstelm_b_idx_lo(<16 x i8> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.b: argument out of range
+entry:
+  call void @llvm.loongarch.lsx.vstelm.b(<16 x i8> %va, i8* %p, i32 1, i32 -1)
+  ret void
+}
+
+define void @lsx_vstelm_b_idx_hi(<16 x i8> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.b: argument out of range
+entry:
+  call void @llvm.loongarch.lsx.vstelm.b(<16 x i8> %va, i8* %p, i32 1, i32 16)
+  ret void
+}
+
+declare void @llvm.loongarch.lsx.vstelm.h(<8 x i16>, i8*, i32, i32)
+
+define void @lsx_vstelm_h_lo(<8 x i16> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.h: argument out of range or not a multiple of 2.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.h(<8 x i16> %va, i8* %p, i32 -258, i32 7)
+  ret void
+}
+
+define void @lsx_vstelm_h_hi(<8 x i16> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.h: argument out of range or not a multiple of 2.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.h(<8 x i16> %va, i8* %p, i32 256, i32 7)
+  ret void
+}
+
+define void @lsx_vstelm_h_idx_lo(<8 x i16> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.h: argument out of range or not a multiple of 2.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.h(<8 x i16> %va, i8* %p, i32 2, i32 -1)
+  ret void
+}
+
+define void @lsx_vstelm_h_idx_hi(<8 x i16> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.h: argument out of range or not a multiple of 2.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.h(<8 x i16> %va, i8* %p, i32 2, i32 8)
+  ret void
+}
+
+declare void @llvm.loongarch.lsx.vstelm.w(<4 x i32>, i8*, i32, i32)
+
+define void @lsx_vstelm_w_lo(<4 x i32> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.w: argument out of range or not a multiple of 4.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.w(<4 x i32> %va, i8* %p, i32 -516, i32 3)
+  ret void
+}
+
+define void @lsx_vstelm_w_hi(<4 x i32> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.w: argument out of range or not a multiple of 4.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.w(<4 x i32> %va, i8* %p, i32 512, i32 3)
+  ret void
+}
+
+define void @lsx_vstelm_w_idx_lo(<4 x i32> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.w: argument out of range or not a multiple of 4.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.w(<4 x i32> %va, i8* %p, i32 4, i32 -1)
+  ret void
+}
+
+define void @lsx_vstelm_w_idx_hi(<4 x i32> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.w: argument out of range or not a multiple of 4.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.w(<4 x i32> %va, i8* %p, i32 4, i32 4)
+  ret void
+}
+
+declare void @llvm.loongarch.lsx.vstelm.d(<2 x i64>, i8*, i32, i32)
+
+define void @lsx_vstelm_d_lo(<2 x i64> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.d: argument out of range or not a multiple of 8.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.d(<2 x i64> %va, i8* %p, i32 -1032, i32 1)
+  ret void
+}
+
+define void @lsx_vstelm_d_hi(<2 x i64> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.d: argument out of range or not a multiple of 8.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.d(<2 x i64> %va, i8* %p, i32 1024, i32 1)
+  ret void
+}
+
+define void @lsx_vstelm_d_idx_lo(<2 x i64> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.d: argument out of range or not a multiple of 8.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.d(<2 x i64> %va, i8* %p, i32 8, i32 -1)
+  ret void
+}
+
+define void @lsx_vstelm_d_idx_hi(<2 x i64> %va, i8* %p) nounwind {
+; CHECK: llvm.loongarch.lsx.vstelm.d: argument out of range or not a multiple of 8.
+entry:
+  call void @llvm.loongarch.lsx.vstelm.d(<2 x i64> %va, i8* %p, i32 8, i32 2)
+  ret void
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-stelm-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-stelm-non-imm.ll
new file mode 100644
index 000000000000..f53932f79035
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-stelm-non-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare void @llvm.loongarch.lsx.vstelm.b(<16 x i8>, i8*, i32, i32)
+
+define void @lsx_vstelm_b(<16 x i8> %va, i8* %p, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  call void @llvm.loongarch.lsx.vstelm.b(<16 x i8> %va, i8* %p, i32 %b, i32 1)
+  ret void
+}
+
+define void @lsx_vstelm_b_idx(<16 x i8> %va, i8* %p, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  call void @llvm.loongarch.lsx.vstelm.b(<16 x i8> %va, i8* %p, i32 1, i32 %b)
+  ret void
+}
+
+declare void @llvm.loongarch.lsx.vstelm.h(<8 x i16>, i8*, i32, i32)
+
+define void @lsx_vstelm_h(<8 x i16> %va, i8* %p, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  call void @llvm.loongarch.lsx.vstelm.h(<8 x i16> %va, i8* %p, i32 %b, i32 1)
+  ret void
+}
+
+define void @lsx_vstelm_h_idx(<8 x i16> %va, i8* %p, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  call void @llvm.loongarch.lsx.vstelm.h(<8 x i16> %va, i8* %p, i32 2, i32 %b)
+  ret void
+}
+
+declare void @llvm.loongarch.lsx.vstelm.w(<4 x i32>, i8*, i32, i32)
+
+define void @lsx_vstelm_w(<4 x i32> %va, i8* %p, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  call void @llvm.loongarch.lsx.vstelm.w(<4 x i32> %va, i8* %p, i32 %b, i32 1)
+  ret void
+}
+
+define void @lsx_vstelm_w_idx(<4 x i32> %va, i8* %p, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  call void @llvm.loongarch.lsx.vstelm.w(<4 x i32> %va, i8* %p, i32 4, i32 %b)
+  ret void
+}
+
+declare void @llvm.loongarch.lsx.vstelm.d(<2 x i64>, i8*, i32, i32)
+
+define void @lsx_vstelm_d(<2 x i64> %va, i8* %p, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  call void @llvm.loongarch.lsx.vstelm.d(<2 x i64> %va, i8* %p, i32 %b, i32 1)
+  ret void
+}
+
+define void @lsx_vstelm_d_idx(<2 x i64> %va, i8* %p, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  call void @llvm.loongarch.lsx.vstelm.d(<2 x i64> %va, i8* %p, i32 8, i32 %b)
+  ret void
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-subi-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-subi-invalid-imm.ll
new file mode 100644
index 000000000000..96cc1241fbf3
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-subi-invalid-imm.ll
@@ -0,0 +1,65 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsubi.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsubi_bu_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsubi.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsubi.bu(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vsubi_bu_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsubi.bu: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsubi.bu(<16 x i8> %va, i32 32)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsubi.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsubi_hu_lo(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsubi.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsubi.hu(<8 x i16> %va, i32 -1)
+  ret <8 x i16> %res
+}
+
+define <8 x i16> @lsx_vsubi_hu_hi(<8 x i16> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsubi.hu: argument out of range
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsubi.hu(<8 x i16> %va, i32 32)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsubi.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsubi_wu_lo(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsubi.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsubi.wu(<4 x i32> %va, i32 -1)
+  ret <4 x i32> %res
+}
+
+define <4 x i32> @lsx_vsubi_wu_hi(<4 x i32> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsubi.wu: argument out of range
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsubi.wu(<4 x i32> %va, i32 32)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsubi.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsubi_du_lo(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsubi.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsubi.du(<2 x i64> %va, i32 -1)
+  ret <2 x i64> %res
+}
+
+define <2 x i64> @lsx_vsubi_du_hi(<2 x i64> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vsubi.du: argument out of range
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsubi.du(<2 x i64> %va, i32 32)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-subi-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-subi-non-imm.ll
new file mode 100644
index 000000000000..162f9ad131c7
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-subi-non-imm.ll
@@ -0,0 +1,37 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vsubi.bu(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vsubi_bu(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vsubi.bu(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
+
+declare <8 x i16> @llvm.loongarch.lsx.vsubi.hu(<8 x i16>, i32)
+
+define <8 x i16> @lsx_vsubi_hu(<8 x i16> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <8 x i16> @llvm.loongarch.lsx.vsubi.hu(<8 x i16> %va, i32 %b)
+  ret <8 x i16> %res
+}
+
+declare <4 x i32> @llvm.loongarch.lsx.vsubi.wu(<4 x i32>, i32)
+
+define <4 x i32> @lsx_vsubi_wu(<4 x i32> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <4 x i32> @llvm.loongarch.lsx.vsubi.wu(<4 x i32> %va, i32 %b)
+  ret <4 x i32> %res
+}
+
+declare <2 x i64> @llvm.loongarch.lsx.vsubi.du(<2 x i64>, i32)
+
+define <2 x i64> @lsx_vsubi_du(<2 x i64> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <2 x i64> @llvm.loongarch.lsx.vsubi.du(<2 x i64> %va, i32 %b)
+  ret <2 x i64> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-xori-invalid-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-xori-invalid-imm.ll
new file mode 100644
index 000000000000..5f5613189ac8
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-xori-invalid-imm.ll
@@ -0,0 +1,17 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vxori.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vxori_b_lo(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vxori.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vxori.b(<16 x i8> %va, i32 -1)
+  ret <16 x i8> %res
+}
+
+define <16 x i8> @lsx_vxori_b_hi(<16 x i8> %va) nounwind {
+; CHECK: llvm.loongarch.lsx.vxori.b: argument out of range
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vxori.b(<16 x i8> %va, i32 256)
+  ret <16 x i8> %res
+}
diff --git a/llvm/test/CodeGen/LoongArch/lsx/intrinsic-xori-non-imm.ll b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-xori-non-imm.ll
new file mode 100644
index 000000000000..4238d89120f1
--- /dev/null
+++ b/llvm/test/CodeGen/LoongArch/lsx/intrinsic-xori-non-imm.ll
@@ -0,0 +1,10 @@
+; RUN: not llc --mtriple=loongarch64 --mattr=+lsx < %s 2>&1 | FileCheck %s
+
+declare <16 x i8> @llvm.loongarch.lsx.vxori.b(<16 x i8>, i32)
+
+define <16 x i8> @lsx_vxori_b(<16 x i8> %va, i32 %b) nounwind {
+; CHECK: immarg operand has non-immediate parameter
+entry:
+  %res = call <16 x i8> @llvm.loongarch.lsx.vxori.b(<16 x i8> %va, i32 %b)
+  ret <16 x i8> %res
+}
-- 
2.20.1

